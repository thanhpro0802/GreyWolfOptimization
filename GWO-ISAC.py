# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tZP-wZ14afqRh2xfRg9oPp1wBBxAInL4
"""

import numpy as np
import matplotlib.pyplot as plt

# ===================== PARAMETERS =====================
N_t = 16        # antennas per AP
M_t = 2         # number of APs
U = 5           # users
T = 1           # targets

Nt_total = N_t * M_t
P_AP = 1.0
P_total = M_t * P_AP
noise = 1e-3

# GWO parameters
n_wolves = 30
max_iter = 100

np.random.seed(2)

# ===================== CHANNEL MODEL =====================
def generate_channels(dist_comm=30, dist_sens=30):
    Hc = (np.random.randn(U, Nt_total) + 1j*np.random.randn(U, Nt_total)) / np.sqrt(dist_comm)
    hs = (np.random.randn(Nt_total) + 1j*np.random.randn(Nt_total)) / np.sqrt(dist_sens)
    return Hc, hs

# ===================== SINR FUNCTIONS =====================
def comm_sinr(wc, Hc):
    sinrs = []
    for u in range(U):
        signal = np.abs(Hc[u] @ wc)**2
        interference = sum(np.abs(Hc[j] @ wc)**2 for j in range(U) if j != u)
        sinrs.append(signal / (interference + noise))
    return np.min(sinrs)

def sensing_sinr(ws, hs):
    return np.abs(hs @ ws)**2 / noise

# ===================== FITNESS FUNCTION =====================
def fitness(w, Hc, hs, rho):
    wc = w[:Nt_total]
    ws = w[Nt_total:]

    if np.linalg.norm(wc) != 0:
        wc = wc / np.linalg.norm(wc) * np.sqrt(P_total * rho)
    else:
        wc = np.zeros_like(wc)

    if np.linalg.norm(ws) != 0:
        ws = ws / np.linalg.norm(ws) * np.sqrt(P_total * (1 - rho))
    else:
        ws = np.zeros_like(ws)

    f_comm = np.log2(1 + comm_sinr(wc, Hc))
    f_sens = np.log2(1 + sensing_sinr(ws, hs))

    alpha = 0.5
    return alpha * f_comm + (1 - alpha) * f_sens

# ===================== GWO OPTIMIZER =====================
def gwo_optimize(Hc, hs, rho):
    dim = 2 * Nt_total
    wolves = np.random.randn(n_wolves, dim)

    alpha_wolf = np.zeros(dim)
    beta_wolf = np.zeros(dim)
    delta_wolf = np.zeros(dim)

    alpha_score = -np.inf
    beta_score = -np.inf
    delta_score = -np.inf

    for t in range(max_iter):
        a = 2 - 2 * t / max_iter

        for i in range(n_wolves):
            score = fitness(wolves[i], Hc, hs, rho)

            if score > alpha_score:
                delta_score, delta_wolf = beta_score, beta_wolf.copy()
                beta_score, beta_wolf = alpha_score, alpha_wolf.copy()
                alpha_score, alpha_wolf = score, wolves[i].copy()
            elif score > beta_score:
                delta_score, delta_wolf = beta_score, beta_wolf.copy()
                beta_score, beta_wolf = score, wolves[i].copy()
            elif score > delta_score:
                delta_score, delta_wolf = score, wolves[i].copy()

        for i in range(n_wolves):
            for j in range(dim):
                r1, r2 = np.random.rand(), np.random.rand()
                A1 = 2*a*r1 - a
                C1 = 2*r2
                X1 = alpha_wolf[j] - A1 * abs(C1*alpha_wolf[j] - wolves[i, j])

                r1, r2 = np.random.rand(), np.random.rand()
                A2 = 2*a*r1 - a
                C2 = 2*r2
                X2 = beta_wolf[j] - A2 * abs(C2*beta_wolf[j] - wolves[i, j])

                r1, r2 = np.random.rand(), np.random.rand()
                A3 = 2*a*r1 - a
                C3 = 2*r2
                X3 = delta_wolf[j] - A3 * abs(C3*delta_wolf[j] - wolves[i, j])

                wolves[i, j] = (X1 + X2 + X3) / 3

    return alpha_wolf

# ===================== FIGURE 1: VS POWER RATIO =====================
rho_list = np.arange(0.0, 1.01, 0.1)   # step = 0.1
comm_vals = []
sens_vals = []

for rho in rho_list:
    Hc, hs = generate_channels()
    w = gwo_optimize(Hc, hs, rho)

    wc = w[:Nt_total]
    ws = w[Nt_total:]

    wc = wc / np.linalg.norm(wc) * np.sqrt(P_total * rho) if np.linalg.norm(wc) != 0 else np.zeros_like(wc)
    ws = ws / np.linalg.norm(ws) * np.sqrt(P_total * (1 - rho)) if np.linalg.norm(ws) != 0 else np.zeros_like(ws)

    comm_vals.append(comm_sinr(wc, Hc))
    sens_vals.append(sensing_sinr(ws, hs))

fig1, ax1 = plt.subplots(2, 1, figsize=(8, 10))

ax1[0].plot(rho_list, comm_vals, 'm--D', linewidth=2)
ax1[0].set_xlabel('Communication Power Ratio (ρ)')
ax1[0].set_ylabel('Min Comm SINR')
ax1[0].set_title('JSC Beam Optimization (GWO) – Communication')
ax1[0].set_xticks(np.arange(0, 1.01, 0.1))
ax1[0].grid(True)

ax1[1].plot(rho_list, sens_vals, 'm--D', linewidth=2)
ax1[1].set_xlabel('Communication Power Ratio (ρ)')
ax1[1].set_ylabel('Target SINR')
ax1[1].set_title('JSC Beam Optimization (GWO) – Sensing')
ax1[1].set_xticks(np.arange(0, 1.01, 0.1))
ax1[1].grid(True)

plt.tight_layout()
plt.show()

# ===================== FIGURE 2: VS DISTANCE =====================
dist_list = np.arange(5, 51, 5)   # step = 5 m
comm_vals = []
sens_vals = []

rho = 0.5

for d in dist_list:
    Hc, hs = generate_channels(dist_comm=d, dist_sens=d)
    w = gwo_optimize(Hc, hs, rho)

    wc = w[:Nt_total]
    ws = w[Nt_total:]

    wc = wc / np.linalg.norm(wc) * np.sqrt(P_total * rho) if np.linalg.norm(wc) != 0 else np.zeros_like(wc)
    ws = ws / np.linalg.norm(ws) * np.sqrt(P_total * (1 - rho)) if np.linalg.norm(ws) != 0 else np.zeros_like(ws)

    comm_vals.append(comm_sinr(wc, Hc))
    sens_vals.append(sensing_sinr(ws, hs))

fig2, ax2 = plt.subplots(2, 1, figsize=(8, 10))

ax2[0].plot(dist_list, comm_vals, 'm--D', linewidth=2)
ax2[0].set_xlabel('Target–Closest UE Distance (m)')
ax2[0].set_ylabel('Min Comm SINR')
ax2[0].set_title('JSC Beam Optimization (GWO) – Communication')
ax2[0].set_xticks(np.arange(5, 51, 5))
ax2[0].grid(True)

ax2[1].plot(dist_list, sens_vals, 'm--D', linewidth=2)
ax2[1].set_xlabel('Target–Closest UE Distance (m)')
ax2[1].set_ylabel('Target SINR')
ax2[1].set_title('JSC Beam Optimization (GWO) – Sensing')
ax2[1].set_xticks(np.arange(5, 51, 5))
ax2[1].grid(True)

plt.tight_layout()
plt.show()