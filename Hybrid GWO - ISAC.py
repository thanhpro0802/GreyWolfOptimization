# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JLV0uKx7s8qZfgmIy-vr486NA1A3bmdK
"""

import numpy as np
import matplotlib.pyplot as plt

# =========================================================
# SYSTEM PARAMETERS
# =========================================================
N_t = 16
M_t = 2
U = 5
T = 1

Nt_total = N_t * M_t
P_AP = 1.0
P_total = M_t * P_AP
noise = 1e-3

np.random.seed(1)

# =========================================================
# HYBRID GWO–PSO PARAMETERS
# =========================================================
n_particles = 30
max_iter = 100

w_inertia = 0.7
c1 = 1.5
c2 = 1.5

# =========================================================
# CHANNEL MODEL
# =========================================================
def generate_channels(dist=30):
    Hc = (np.random.randn(U, Nt_total) + 1j*np.random.randn(U, Nt_total)) / np.sqrt(dist)
    hs = (np.random.randn(Nt_total) + 1j*np.random.randn(Nt_total)) / np.sqrt(dist)
    return Hc, hs

# =========================================================
# COMMUNICATION SNR
# =========================================================
def comm_snr(wc, Hc):
    snrs = []
    for u in range(U):
        snrs.append(np.abs(Hc[u] @ wc)**2 / noise)
    return np.min(snrs)

# =========================================================
# SENSING SINR
# =========================================================
def sensing_sinr(ws, wc, hs):
    signal = np.abs(hs @ ws)**2
    interference = np.abs(hs @ wc)**2
    return signal / (interference + noise)

# =========================================================
# FITNESS FUNCTION
# =========================================================
def fitness(x, Hc, hs, rho):
    wc = x[:Nt_total]
    ws = x[Nt_total:]

    wc = wc / np.linalg.norm(wc) * np.sqrt(P_total * rho)
    ws = ws / np.linalg.norm(ws) * np.sqrt(P_total * (1 - rho))

    f_comm = np.log2(1 + comm_snr(wc, Hc))
    f_sens = np.log2(1 + sensing_sinr(ws, wc, hs))

    alpha = 0.5
    return alpha * f_comm + (1 - alpha) * f_sens

# =========================================================
# HYBRID GWO–PSO OPTIMIZER
# =========================================================
def hybrid_gwo_pso(Hc, hs, rho):
    dim = 2 * Nt_total

    X = np.random.randn(n_particles, dim)
    V = np.zeros((n_particles, dim))

    pbest = X.copy()
    pbest_score = np.full(n_particles, -np.inf)

    alpha = beta = delta = np.zeros(dim)
    alpha_score = beta_score = delta_score = -np.inf

    for t in range(max_iter):
        a = 2 - 2 * t / max_iter

        for i in range(n_particles):
            score = fitness(X[i], Hc, hs, rho)

            if score > pbest_score[i]:
                pbest_score[i] = score
                pbest[i] = X[i].copy()

            if score > alpha_score:
                delta_score, delta = beta_score, beta.copy()
                beta_score, beta = alpha_score, alpha.copy()
                alpha_score, alpha = score, X[i].copy()
            elif score > beta_score:
                delta_score, delta = beta_score, beta.copy()
                beta_score, beta = score, X[i].copy()
            elif score > delta_score:
                delta_score, delta = score, X[i].copy()

        for i in range(n_particles):
            r1, r2 = np.random.rand(), np.random.rand()

            V[i] = (
                w_inertia * V[i]
                + c1 * r1 * (pbest[i] - X[i])
                + c2 * r2 * (alpha - X[i])
            )

            X_gwo = (alpha + beta + delta) / 3
            X[i] = 0.5 * (X_gwo + X[i] + V[i])

    return alpha

# =========================================================
# FIGURE 1: VS COMMUNICATION POWER RATIO
# =========================================================
rho_list = np.arange(0.0, 1.01, 0.1)
comm_vals, sens_vals = [], []

for rho in rho_list:
    Hc, hs = generate_channels()
    w = hybrid_gwo_pso(Hc, hs, rho)

    wc = w[:Nt_total]
    ws = w[Nt_total:]

    wc = wc / np.linalg.norm(wc) * np.sqrt(P_total * rho)
    ws = ws / np.linalg.norm(ws) * np.sqrt(P_total * (1 - rho))

    comm_vals.append(10*np.log10(comm_snr(wc, Hc)))
    sens_vals.append(10*np.log10(sensing_sinr(ws, wc, hs)))

plt.figure(figsize=(10,4))

plt.subplot(1,2,1)
plt.plot(rho_list, comm_vals, 'm--D', linewidth=2)
plt.xlabel('Communication Power Ratio (ρ)')
plt.ylabel('Min Comm SNR')
plt.grid(True)

plt.subplot(1,2,2)
plt.plot(rho_list, sens_vals, 'm--D', linewidth=2)
plt.xlabel('Communication Power Ratio (ρ)')
plt.ylabel('Target SINR')
plt.grid(True)

plt.suptitle('Hybrid GWO–PSO Performance vs Communication Power Ratio')
plt.tight_layout()
plt.show()

# =========================================================
# FIGURE 2: VS TARGET–UE DISTANCE
# =========================================================
dist_list = np.arange(5, 51, 5)
comm_vals, sens_vals = [], []

rho = 0.5

for d in dist_list:
    Hc, hs = generate_channels(dist=d)
    w = hybrid_gwo_pso(Hc, hs, rho)

    wc = w[:Nt_total]
    ws = w[Nt_total:]

    wc = wc / np.linalg.norm(wc) * np.sqrt(P_total * rho)
    ws = ws / np.linalg.norm(ws) * np.sqrt(P_total * (1 - rho))

    comm_vals.append(10*np.log10(comm_snr(wc, Hc)))
    sens_vals.append(10*np.log10(sensing_sinr(ws, wc, hs)))

plt.figure(figsize=(10,4))

plt.subplot(1,2,1)
plt.plot(dist_list, comm_vals, 'm--D', linewidth=2)
plt.xlabel('Target–Closest UE Distance (m)')
plt.ylabel('Min Comm SNR')
plt.grid(True)

plt.subplot(1,2,2)
plt.plot(dist_list, sens_vals, 'm--D', linewidth=2)
plt.xlabel('Target–Closest UE Distance (m)')
plt.ylabel('Target SINR')
plt.grid(True)

plt.suptitle('Hybrid GWO–PSO Performance vs Target Distance')
plt.tight_layout()
plt.show()